<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Catch the Right One (Social Engineering)</title>
  <style>
    * { box-sizing: border-box; }
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      background:#0b1220;
      color:#e8eefc;
      overflow:hidden;
    }
    #wrap{display:grid;grid-template-rows:auto 1fr auto;height:100vh;width:100vw;}

    #hud{
      padding:12px 14px 10px;
      background:linear-gradient(180deg,rgba(12,20,40,.95),rgba(12,20,40,.55));
      border-bottom:1px solid rgba(255,255,255,.08);
    }
    #row1{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-bottom:8px;}
    .pill{
      padding:6px 10px;border-radius:999px;font-size:13px;white-space:nowrap;
      background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.12);
    }
    #questionBox{
      padding:10px 12px;border-radius:12px;
      background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.10);
      font-size:16px;line-height:1.35;max-width:1100px;margin:0 auto;
    }
    #questionBox b{color:#fff;}

    #stage{position:relative;width:100%;height:100%;}
    canvas{
      width:100%;height:100%;display:block;touch-action:none;
      background:
        radial-gradient(1200px 600px at 20% 10%, rgba(73,132,255,0.22), transparent 55%),
        radial-gradient(800px 500px at 85% 40%, rgba(245,124,179,0.18), transparent 55%),
        linear-gradient(180deg, #0b1220, #071025);
    }

    #footer{
      padding:10px 14px;
      background:linear-gradient(0deg,rgba(12,20,40,.95),rgba(12,20,40,.55));
      border-top:1px solid rgba(255,255,255,.08);
      display:flex;gap:10px;align-items:center;justify-content:space-between;
    }
    #tips{font-size:12px;opacity:.9;}
    #btns{display:flex;gap:8px;flex-wrap:wrap;justify-content:flex-end;}
    button{
      appearance:none;border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.10);color:#e8eefc;
      padding:8px 10px;border-radius:10px;font-size:13px;cursor:pointer;
    }
    button:hover{background:rgba(255,255,255,.14);}
    button:active{transform:translateY(1px);}

    .overlay{
      position:absolute;inset:0;display:none;align-items:center;justify-content:center;
      padding:18px;background:rgba(0,0,0,.55);backdrop-filter:blur(6px);
    }
    .overlay.show{display:flex;}
    .card{
      width:min(720px,96vw);border-radius:16px;padding:16px 16px 14px;
      background:rgba(15,24,48,.95);border:1px solid rgba(255,255,255,.14);
      box-shadow:0 20px 60px rgba(0,0,0,.35);
    }
    .card h2{margin:0 0 8px;font-size:18px;}
    .card p,.card li{font-size:14px;line-height:1.45;opacity:.95;}
    .card ul{margin:10px 0 0 18px;}
    .card .row{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-top:12px;flex-wrap:wrap;}
    .muted{opacity:.85;}

    #bigFeedback{
      position:absolute;left:50%;top:46%;transform:translate(-50%,-50%);
      font-size:clamp(26px,4.5vw,46px);font-weight:800;letter-spacing:.5px;
      padding:10px 16px;border-radius:14px;border:2px solid rgba(255,255,255,.20);
      background:rgba(10,18,36,.60);
      display:none;pointer-events:none;text-align:center;max-width:92vw;
    }

    @media (max-width:520px){ #questionBox{font-size:15px;} #tips{display:none;} }
  </style>
</head>

<body>
<div id="wrap">
  <div id="hud">
    <div id="row1">
      <div class="pill" id="scorePill">Score: 0</div>
      <div class="pill" id="progressPill">Question 1 of 12</div>
      <div class="pill">Catch: 1 option</div>
    </div>
    <div id="questionBox"><b>Question:</b> <span id="qText">Press Start to begin.</span></div>
  </div>

  <div id="stage">
    <canvas id="game"></canvas>
    <div id="bigFeedback"></div>

    <div class="overlay show" id="startOverlay">
      <div class="card">
        <h2>Catch the Right One (Social Engineering)</h2>
        <p class="muted">
          A question appears at the top. Four options will fall. Move the catcher and catch the <b>correct</b> option.
          You can catch <b>only one</b> option per question. Speed is not important.
        </p>
        <ul>
          <li><b>Desktop:</b> Left / Right arrow keys</li>
          <li><b>Mobile:</b> Drag the catcher left or right</li>
        </ul>
        <div class="row">
          <span class="muted">Tip: Read first, then move.</span>
          <button id="btnStart">Start</button>
        </div>
      </div>
    </div>

    <div class="overlay" id="endOverlay">
      <div class="card">
        <h2>Session Completed</h2>
        <p id="finalLine" class="muted"></p>
        <p id="summaryLine" class="muted"></p>
        <div class="row">
          <button id="btnReview">Show review</button>
          <button id="btnRestart">Restart</button>
        </div>
        <div id="reviewBox" style="display:none;margin-top:10px;"></div>
      </div>
    </div>
  </div>

  <div id="footer">
    <div id="tips">Use arrows (desktop) or drag the catcher (mobile). Catch one option only.</div>
    <div id="btns">
      <button id="btnPause">Pause</button>
      <button id="btnSkip">Skip</button>
      <button id="btnHow">How to play</button>
    </div>
  </div>
</div>

<script>
/* QUESTIONS (Social Engineering unit) */
const QUESTIONS = [
  { q:"Social engineering is mainly the art of:", options:[
      "Psychologically manipulating people to obtain confidential information",
      "Upgrading hardware to stop viruses",
      "Encrypting every file on a device",
      "Writing code to exploit buffer overflow"
    ], correctIndex:0, feedback:"It targets humans, not the technology." },
  { q:"Which phase in the social engineering attack cycle comes first?", options:[
      "Exploit trust factor","Research","Cloak activities","Utilise & execute"
    ], correctIndex:1, feedback:"Attackers start by gathering info about the target." },
  { q:"'Developing rapport and trust' mainly aims to:", options:[
      "Install malware automatically","Make the victim doubt all coworkers","Increase bandwidth for the attacker",
      "Make the target more likely to share information or do a requested action"
    ], correctIndex:3, feedback:"Trust increases compliance and information sharing." },
  { q:"Using an established relationship to get the desired info/action is:", options:[
      "Exploiting trust factor","Evolve/regress","Research","Waste management"
    ], correctIndex:0, feedback:"This is where trust is used against the victim." },
  { q:"Social engineering attacks are broadly split into:", options:[
      "Hardware, software, firmware","Physical, remote, and hybrid","Email, SMS, and VoIP only","Open-source, closed-source, freeware"
    ], correctIndex:1, feedback:"The unit groups them as physical, remote and hybrid." },
  { q:"Piggybacking refers to:", options:[
      "Entering a restricted area by convincing/using an authorized person","Listening to private conversations",
      "Throwing documents into the trash","Sending fake bank emails"
    ], correctIndex:0, feedback:"Physical access using someone else’s authorization." },
  { q:"Obtaining information from discarded papers/devices is:", options:[
      "Impersonation","Dumpster driving","Vishing","Pop-up interception"
    ], correctIndex:1, feedback:"Dumpster driving exploits poor disposal practices." },
  { q:"Reverse social engineering is:", options:[
      "Victim asks attacker for help due to a scenario created by attacker","Attacker deletes evidence immediately after entry",
      "Attacker uses only email and never phone","Victim uses strong passwords to stop phishing"
    ], correctIndex:0, feedback:"Attacker creates a problem then offers ‘help’." },
  { q:"Phishing is a bait-and-hook approach where:", options:[
      "Bait is a USB drive and hook is a printer",
      "Bait is the email message and hook is how victim’s information is captured",
      "Bait is strong encryption and hook is a firewall",
      "Bait is a password policy and hook is a data label"
    ], correctIndex:1, feedback:"Email lures victims; links/sites/calls capture data." },
  { q:"Customized phishing targeted at one person is called:", options:[
      "Whale phishing","419 scam","Spear phishing","Diversion theft"
    ], correctIndex:2, feedback:"Spear phishing is targeted and uses prior research." },
  { q:"Phone/IVR phishing is also known as:", options:[
      "Vishing","Smishing","Eavesdropping","Piggybacking"
    ], correctIndex:0, feedback:"Vishing uses voice calls/IVR to trick users." },
  { q:"A 'road apple' attack usually involves:", options:[
      "Repeated false alarms to reduce response later",
      "Leaving a storage device (USB/CD) hoping staff plug it in",
      "Pretending to be speech-impaired on a call",
      "Redirecting victim to a bank’s real website"
    ], correctIndex:1, feedback:"Baiting with physical media that may carry a payload." }
];

/* SETTINGS */
const SETTINGS = {
  questionsPerSession: Math.min(12, QUESTIONS.length),
  fallSpeed: 160,
  spawnY: -90,
  catcherWidth: 220,   // bigger so it’s visible
  catcherHeight: 44,
  optionW: 240,
  optionH: 74,
  feedbackMs: 650,
  shakeMs: 220
};

/* CANVAS */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d", { alpha: true });

function ensureCanvasSize() {
  const rect = canvas.getBoundingClientRect();
  const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  const w = Math.floor(rect.width * dpr);
  const h = Math.floor(rect.height * dpr);
  if (canvas.width !== w || canvas.height !== h) {
    canvas.width = w;
    canvas.height = h;
  }
}

/* UI */
const qTextEl = document.getElementById("qText");
const scorePill = document.getElementById("scorePill");
const progressPill = document.getElementById("progressPill");
const startOverlay = document.getElementById("startOverlay");
const endOverlay = document.getElementById("endOverlay");
const bigFeedback = document.getElementById("bigFeedback");
const finalLine = document.getElementById("finalLine");
const summaryLine = document.getElementById("summaryLine");
const reviewBox = document.getElementById("reviewBox");

document.getElementById("btnStart").addEventListener("click", () => {
  startOverlay.classList.remove("show");
  startSession();
});
document.getElementById("btnHow").addEventListener("click", () => startOverlay.classList.add("show"));

document.getElementById("btnRestart").addEventListener("click", () => {
  endOverlay.classList.remove("show");
  reviewBox.style.display = "none";
  startSession();
});
document.getElementById("btnReview").addEventListener("click", () => {
  reviewBox.style.display = (reviewBox.style.display === "none") ? "block" : "none";
});

const btnPause = document.getElementById("btnPause");
btnPause.addEventListener("click", () => {
  state.paused = !state.paused;
  btnPause.textContent = state.paused ? "Resume" : "Pause";
});

document.getElementById("btnSkip").addEventListener("click", () => {
  if (!state.running || state.awaitingNext) return;
  recordAttempt(null, false, "Skipped");
  nextQuestion();
});

/* COLORS */
const OPTION_COLORS = [
  { a:"#ff4d6d", b:"#ff9f1c" }, // A
  { a:"#5eead4", b:"#22c55e" }, // B
  { a:"#60a5fa", b:"#a78bfa" }, // C
  { a:"#f59e0b", b:"#fde047" }  // D
];

/* STATE */
const state = {
  running:false, paused:false, awaitingNext:false,
  score:0, qIndex:0, sessionQuestions:[], current:null,
  options:[],
  catcher:{ x:0, y:0 },
  input:{ left:false, right:false, dragging:false, targetX:null },
  fx:{ flash:null, flashT:0, shakeT:0, shakeAmp:0 },
  log:[]
};

function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = (Math.random()*(i+1))|0;
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a;
}

function anchorCatcherToBottom() {
  // Always visible: 24px padding from bottom of canvas
  state.catcher.y = canvas.height - 24 - SETTINGS.catcherHeight;
}

function startSession(){
  ensureCanvasSize();
  state.running = true;
  state.paused = false;
  state.awaitingNext = false;
  btnPause.textContent = "Pause";
  state.score = 0;
  state.qIndex = 0;
  state.log = [];
  state.sessionQuestions = shuffle(QUESTIONS).slice(0, SETTINGS.questionsPerSession);

  state.catcher.x = canvas.width/2;
  anchorCatcherToBottom();

  loadQuestion(0);
}

function loadQuestion(idx){
  state.qIndex = idx;
  state.current = state.sessionQuestions[idx];

  qTextEl.textContent = state.current.q;
  scorePill.textContent = `Score: ${state.score}`;
  progressPill.textContent = `Question ${idx+1} of ${state.sessionQuestions.length}`;

  const scale = Math.min(1, canvas.width / 1100);
  const ow = Math.floor(SETTINGS.optionW * scale);
  const oh = Math.floor(SETTINGS.optionH * scale);

  const pad = Math.max(14, Math.floor(canvas.width * 0.05));
  const totalW = 4*ow;
  const gap = Math.max(14, Math.floor((canvas.width - pad*2 - totalW)/3));
  const startX = Math.max(pad, (canvas.width - (4*ow + 3*gap))/2);

  state.options = [];
  const labels = ["A","B","C","D"];
  for(let i=0;i<4;i++){
    state.options.push({
      idx:i, label:labels[i],
      text: state.current.options[i],
      x: startX + i*(ow+gap),
      y: SETTINGS.spawnY,
      w: ow, h: oh,
      alive:true
    });
  }

  state.awaitingNext = false;
}

/* INPUT */
window.addEventListener("keydown",(e)=>{
  if(e.key==="ArrowLeft") state.input.left=true;
  if(e.key==="ArrowRight") state.input.right=true;
});
window.addEventListener("keyup",(e)=>{
  if(e.key==="ArrowLeft") state.input.left=false;
  if(e.key==="ArrowRight") state.input.right=false;
});

function pointerToCanvasX(clientX){
  const rect = canvas.getBoundingClientRect();
  const dpr = canvas.width / rect.width;
  return (clientX - rect.left) * dpr;
}
canvas.addEventListener("pointerdown",(e)=>{
  canvas.setPointerCapture(e.pointerId);
  state.input.dragging=true;
  state.input.targetX = pointerToCanvasX(e.clientX);
});
canvas.addEventListener("pointermove",(e)=>{
  if(!state.input.dragging) return;
  state.input.targetX = pointerToCanvasX(e.clientX);
});
canvas.addEventListener("pointerup",()=>{
  state.input.dragging=false;
  state.input.targetX=null;
});
canvas.addEventListener("pointercancel",()=>{
  state.input.dragging=false;
  state.input.targetX=null;
});

/* LOOP */
let last = performance.now();
requestAnimationFrame(function loop(t){
  ensureCanvasSize();                 // key fix: size stays correct
  anchorCatcherToBottom();            // key fix: catcher stays visible

  const dt = Math.min(0.033, (t-last)/1000);
  last = t;

  if(state.running && !state.paused) update(dt);
  draw();

  requestAnimationFrame(loop);
});

function update(dt){
  let targetX = state.catcher.x;
  if(state.input.left) targetX -= 900*dt;
  if(state.input.right) targetX += 900*dt;
  if(state.input.targetX != null) targetX = state.input.targetX;

  state.catcher.x += (targetX - state.catcher.x) * Math.min(1, 14*dt);

  const half = SETTINGS.catcherWidth/2;
  state.catcher.x = clamp(state.catcher.x, half + 10, canvas.width - half - 10);

  const fall = SETTINGS.fallSpeed * dt;
  for(const o of state.options){
    if(!o.alive) continue;
    o.y += fall;
  }

  if(!state.awaitingNext){
    const c = catcherRect();
    const caught = state.options.find(o => o.alive && rectHit(o, c));
    if(caught) handleCatch(caught);
  }

  if(state.fx.flashT>0) state.fx.flashT -= dt;
  if(state.fx.shakeT>0) state.fx.shakeT -= dt;
}

function handleCatch(opt){
  state.awaitingNext = true;
  for(const o of state.options) o.alive = false;

  const correct = (opt.idx === state.current.correctIndex);

  if(correct){
    state.score += 10;
    flashFX("correct");
    showBigFeedback("Correct!", "correct");
  }else{
    flashFX("wrong");
    shakeFX();
    const corrLabel = ["A","B","C","D"][state.current.correctIndex];
    showBigFeedback(`Wrong! Correct: ${corrLabel}`, "wrong");
  }

  recordAttempt(opt, correct);
  setTimeout(() => nextQuestion(), SETTINGS.feedbackMs);
}

function nextQuestion(){
  bigFeedback.style.display="none";
  state.awaitingNext = false;

  const nxt = state.qIndex + 1;
  if(nxt >= state.sessionQuestions.length) endSession();
  else loadQuestion(nxt);
}

function endSession(){
  state.running = false;
  endOverlay.classList.add("show");

  const correctCount = state.log.filter(r=>r.correct).length;
  finalLine.textContent = `Your score: ${state.score} | Correct: ${correctCount}/${state.sessionQuestions.length}`;
  summaryLine.textContent =
    correctCount >= Math.ceil(state.sessionQuestions.length*0.7)
      ? "Summary: Good understanding. Keep practicing to retain concepts."
      : "Summary: Needs revision. Review the feedback and try again.";

  reviewBox.innerHTML = state.log.map((r,i)=>{
    const tag = r.correct ? "✅ Correct" : "❌ Wrong";
    const chosen = r.chosenLabel ? `${r.chosenLabel}. ${escapeHtml(r.chosenText)}` : "Skipped";
    const correct = `${r.correctLabel}. ${escapeHtml(r.correctText)}`;
    const fb = escapeHtml(r.feedback||"");
    return `
      <div style="padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);margin:8px 0;">
        <div style="font-weight:700;margin-bottom:6px;">Q${i+1}. ${escapeHtml(r.q)}</div>
        <div style="font-size:13px;line-height:1.45;opacity:.95">
          <div>${tag}</div>
          <div><b>Your pick:</b> ${chosen}</div>
          <div><b>Correct:</b> ${correct}</div>
          ${fb ? `<div><b>Feedback:</b> ${fb}</div>` : ""}
        </div>
      </div>
    `;
  }).join("");
}

function recordAttempt(opt, correct, overrideFeedback){
  const labels = ["A","B","C","D"];
  const cIdx = state.current.correctIndex;
  state.log.push({
    q: state.current.q,
    correct,
    chosenLabel: opt ? labels[opt.idx] : null,
    chosenText: opt ? state.current.options[opt.idx] : null,
    correctLabel: labels[cIdx],
    correctText: state.current.options[cIdx],
    feedback: overrideFeedback || state.current.feedback || ""
  });
  scorePill.textContent = `Score: ${state.score}`;
}

/* DRAW */
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // subtle shake on wrong
  let sx=0, sy=0;
  if(state.fx.shakeT>0){
    const k = state.fx.shakeT / (SETTINGS.shakeMs/1000);
    sx = (Math.random()-0.5) * state.fx.shakeAmp * k;
    sy = (Math.random()-0.5) * state.fx.shakeAmp * k;
  }
  ctx.save();
  ctx.translate(sx, sy);

  // floor line (debug/guide)
  ctx.save();
  ctx.globalAlpha = 0.35;
  ctx.strokeStyle = "#ffffff";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.moveTo(0, state.catcher.y + SETTINGS.catcherHeight + 18);
  ctx.lineTo(canvas.width, state.catcher.y + SETTINGS.catcherHeight + 18);
  ctx.stroke();
  ctx.restore();

  // flash tint
  if(state.fx.flashT>0 && state.fx.flash){
    const a = clamp(state.fx.flashT/0.22,0,1)*0.20;
    ctx.save();
    ctx.globalAlpha=a;
    ctx.fillStyle = (state.fx.flash==="correct") ? "#2ee59d" : "#ff4d6d";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();
  }

  for(const o of state.options) if(o.alive) drawOption(o);
  drawCatcher(); // ALWAYS draw catcher

  ctx.restore();
}

function drawOption(o){
  const palette = OPTION_COLORS[o.idx] || {a:"#60a5fa", b:"#a78bfa"};
  const r = 18;

  // glow
  ctx.save();
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = palette.a;
  ctx.beginPath();
  ctx.ellipse(o.x + o.w/2, o.y + o.h/2, o.w*0.58, o.h*0.62, 0, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();

  // card
  const grad = ctx.createLinearGradient(o.x, o.y, o.x + o.w, o.y + o.h);
  grad.addColorStop(0, hexToRgba(palette.a, 0.42));
  grad.addColorStop(1, hexToRgba(palette.b, 0.22));

  roundRect(o.x, o.y, o.w, o.h, r);
  ctx.fillStyle = grad;
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = "rgba(255,255,255,0.24)";
  ctx.stroke();

  // label badge
  const badge = 34;
  roundRect(o.x + 10, o.y + 10, badge, badge, 10);
  const bgrad = ctx.createLinearGradient(o.x, o.y, o.x + badge, o.y + badge);
  bgrad.addColorStop(0, hexToRgba(palette.a, 0.98));
  bgrad.addColorStop(1, hexToRgba(palette.b, 0.88));
  ctx.fillStyle = bgrad;
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,0.28)";
  ctx.stroke();

  ctx.fillStyle = "#081022";
  ctx.font = "900 16px system-ui, sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(o.label, o.x + 10 + badge/2, o.y + 10 + badge/2);

  // option text
  ctx.fillStyle = "rgba(255,255,255,0.96)";
  ctx.font = "700 14px system-ui, sans-serif";
  ctx.textAlign = "left";
  ctx.textBaseline = "top";
  const tx = o.x + 10 + badge + 10;
  const ty = o.y + 12;
  const maxW = o.w - (10 + badge + 22);
  wrapText(o.text, tx, ty, maxW, 18);
}

function drawCatcher(){
  const w = SETTINGS.catcherWidth;
  const h = SETTINGS.catcherHeight;
  const x = state.catcher.x - w/2;
  const y = state.catcher.y;

  // VERY bright catcher (impossible to miss)
  const g = ctx.createLinearGradient(x, y, x+w, y+h);
  g.addColorStop(0, "rgba(0,255,210,0.95)");
  g.addColorStop(0.5, "rgba(120,120,255,0.95)");
  g.addColorStop(1, "rgba(255,90,200,0.95)");

  // shadow behind catcher for contrast
  ctx.save();
  ctx.globalAlpha = 0.6;
  ctx.fillStyle = "rgba(0,0,0,0.45)";
  roundRect(x+4, y+6, w, h, 18);
  ctx.fill();
  ctx.restore();

  roundRect(x, y, w, h, 18);
  ctx.fillStyle = g;
  ctx.fill();
  ctx.lineWidth = 3;
  ctx.strokeStyle = "rgba(255,255,255,0.55)";
  ctx.stroke();

  // top rim
  roundRect(x + 12, y - 14, w - 24, 18, 12);
  ctx.fillStyle = "rgba(255,255,255,0.35)";
  ctx.fill();
  ctx.strokeStyle = "rgba(255,255,255,0.45)";
  ctx.stroke();

  // label
  ctx.fillStyle = "rgba(0,0,0,0.55)";
  roundRect(x + w/2 - 26, y + 7, 52, h - 14, 12);
  ctx.fill();
  ctx.fillStyle = "rgba(255,255,255,0.98)";
  ctx.font = "900 12px system-ui, sans-serif";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("CATCH", x + w/2, y + h/2);
}

/* FX + HELPERS */
function flashFX(kind){ state.fx.flash=kind; state.fx.flashT=0.22; }
function shakeFX(){ state.fx.shakeT = SETTINGS.shakeMs/1000; state.fx.shakeAmp = 10; }
function showBigFeedback(text, kind){
  bigFeedback.textContent = text;
  bigFeedback.style.display = "block";
  bigFeedback.style.borderColor = kind==="correct" ? "rgba(46,229,157,0.70)" : "rgba(255,77,109,0.70)";
}
function catcherRect(){
  const w = SETTINGS.catcherWidth, h = SETTINGS.catcherHeight;
  return { x: state.catcher.x - w/2, y: state.catcher.y - 10, w, h: h + 18 };
}
function rectHit(a,b){
  return (a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y);
}
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function roundRect(x,y,w,h,r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr,y);
  ctx.arcTo(x+w,y,x+w,y+h,rr);
  ctx.arcTo(x+w,y+h,x,y+h,rr);
  ctx.arcTo(x,y+h,x,y,rr);
  ctx.arcTo(x,y,x+w,y,rr);
  ctx.closePath();
}
function wrapText(text, x, y, maxWidth, lineHeight){
  const words = String(text).split(" ");
  let line = "", yy = y;
  for(let n=0;n<words.length;n++){
    const testLine = line + words[n] + " ";
    const mw = ctx.measureText(testLine).width;
    if(mw > maxWidth && n > 0){
      ctx.fillText(line.trim(), x, yy);
      line = words[n] + " ";
      yy += lineHeight;
    } else {
      line = testLine;
    }
  }
  ctx.fillText(line.trim(), x, yy);
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#039;"
  }[m]));
}
function hexToRgba(hex, a){
  const h = hex.replace("#","");
  const r = parseInt(h.substring(0,2),16);
  const g = parseInt(h.substring(2,4),16);
  const b = parseInt(h.substring(4,6),16);
  return `rgba(${r},${g},${b},${a})`;
}
</script>
</body>
</html>
